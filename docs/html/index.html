<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>matf-rg-engine: matf-rg-project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">matf-rg-engine
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Base for project for the Computer Graphics course at Faculty of Mathematics, University of Belgrade</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">matf-rg-project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_engine_DOC"></a> <code>matf-rg-project</code> is the base project for the Computer Graphics course at the Faculty of Mathematics, University of Belgrade for the school year of 2024/2025.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Setup</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Linux</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Debian based (Ubuntu, Debian...)</h3>
<p><b>To setup the necessary libraries, run:</b> <br  />
 <code>./setup.sh</code></p>
<p><b>To generate docs, run:</b> <br  />
 <code>doxygen Doxyfile</code> <br  />
 Open the documentation file in your browser: <code>docs/html/index.html</code></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Engine</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Main loop</h2>
<p>Here is the main loop of the engine. The user of this engine extends and implements the <code>App</code> class. The <code>Engine</code> has clear stages, <code>setup</code>, <code>initialization</code>, <code>loop</code>, <code>poll_events</code>, <code>update</code>, <code>draw</code>, <code>terminate</code>, and <code>on_exit</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>App {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keywordtype">int</span> run(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    engine_setup(argc, argv);</div>
<div class="line">    app_setup();</div>
<div class="line">    initialize();</div>
<div class="line">    <span class="keywordflow">while</span> (loop()) {</div>
<div class="line">        poll_events();</div>
<div class="line">        update();</div>
<div class="line">        draw();</div>
<div class="line">    }</div>
<div class="line">    terminate();</div>
<div class="line">  } <span class="keywordflow">catch</span>(...) { ... }</div>
<div class="line">  <span class="keywordflow">return</span> on_exit();</div>
<div class="line">}</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li><code>engine_setup</code> - here, the engine controllers are setup, afterwards the <code>setup</code> function is called</li>
<li><code>setup</code> - the function that the user of the <code>App</code> overrides and implements a custom setup for the App</li>
<li><code>initialize</code> - <code>App</code> should gather whatever <code>Resources</code> it needs and initialize its state.</li>
<li><code>loop</code> - <code>App</code> can check whether it should continue running. If the <code>loop</code> method returns <code>false</code>, the <code>Main loop</code> stops, and the <code>App</code> terminates.</li>
<li><code>poll_events</code> - <code>App</code> collects information about the events that happened at the <code>Platform</code> and collects user input for the upcoming frame.</li>
<li><code>update</code> - <code>App</code> updates the world state, processes physics, events, and world logic, and reacts to the user inputs.</li>
<li><code>draw</code> - <code>App</code> uses <code>OpenGL</code> and draws the current state of the world.</li>
<li><code>terminate</code> - <code>App</code> terminates its state</li>
<li><code>on_exit</code> -</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
The App class</h2>
<p>Here is the interface of the <code><a class="el" href="d8/d5e/App_8hpp.html" title="Defines the base App class that serves as the application core structure and the entry point.">engine/core/App.hpp</a></code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>App {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">int</span> run(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);</div>
<div class="line">        <span class="keyword">virtual</span> ~App() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">void</span> engine_setup(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);</div>
<div class="line">        <span class="keywordtype">void</span> initialize();</div>
<div class="line">        <span class="keywordtype">void</span> poll_events();</div>
<div class="line">        <span class="keywordtype">bool</span> loop();</div>
<div class="line">        <span class="keywordtype">void</span> update();</div>
<div class="line">        <span class="keywordtype">void</span> draw();</div>
<div class="line">        <span class="keywordtype">void</span> terminate();</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> app_setup() { <span class="comment">// the user extends and implements setup }</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">int</span> on_exit() { <span class="keywordflow">return</span> 0; }</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle_error(<span class="keyword">const</span> Error &amp;);</div>
<div class="line">    };</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Project structure</h2>
<p>Here is how the <code>Engine</code> is structured. You only need to include <code>&lt;<a class="el" href="d3/d48/Engine_8hpp.html" title="Includes all the engine headers.">engine/core/Engine.hpp</a>&gt;</code> in your part of the project and all the header files will be available.</p>
<div class="fragment"><div class="line">├── engine</div>
<div class="line">│   ├── controller</div>
<div class="line">│   │   ├── Controller.hpp</div>
<div class="line">│   │   ├── ControllerManager.hpp</div>
<div class="line">│   │   └── EngineSentinelController.hpp</div>
<div class="line">│   ├── core</div>
<div class="line">│   │   └── App.hpp</div>
<div class="line">│   ├── Engine.hpp</div>
<div class="line">│   ├── graphics</div>
<div class="line">│   │   ├── Camera.hpp</div>
<div class="line">│   │   ├── GraphicsController.hpp</div>
<div class="line">│   │   └── OpenGL.hpp</div>
<div class="line">│   ├── platform</div>
<div class="line">│   │   ├── Input.hpp</div>
<div class="line">│   │   ├── PlatformController.hpp</div>
<div class="line">│   │   ├── PlatformEventObserver.hpp</div>
<div class="line">│   │   └── Window.hpp</div>
<div class="line">│   ├── resources</div>
<div class="line">│   │   ├── Mesh.hpp</div>
<div class="line">│   │   ├── Model.hpp</div>
<div class="line">│   │   ├── ResourcesController.hpp</div>
<div class="line">│   │   ├── ShaderCompiler.hpp</div>
<div class="line">│   │   ├── Shader.hpp</div>
<div class="line">│   │   ├── Skybox.hpp</div>
<div class="line">│   │   └── Texture.hpp</div>
<div class="line">│   └── util</div>
<div class="line">│       ├── ArgParser.hpp</div>
<div class="line">│       ├── Configuration.hpp</div>
<div class="line">│       ├── Errors.hpp</div>
<div class="line">│       └── Utils.hpp</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
How to...</h2>
<h3><a class="anchor" id="autotoc_md9"></a>
How to include and use engine files?</h3>
<p>All the source files (.cpp) go into src/ directory, and all the header files go into the include/ directory. To use the engine, you must include <code>#include &lt;<a class="el" href="d3/d48/Engine_8hpp.html" title="Includes all the engine headers.">engine/core/Engine.hpp</a>&gt;</code>, and all the engine header files will be available.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
How does the engine manage resources?</h3>
<p>For every type of resource, the <code>ResourcesController</code> has a corresponding that retrieves it:</p>
<ul>
<li><code>Model* ResourcesController::model("backpack")</code></li>
<li><code>Shader* ResourcesController::shader("basic")</code></li>
<li><code>Texture* ResourcesController::texture("awesomeface")</code></li>
<li><code>Skybox* ResourcesController::skybox("skybox")</code></li>
</ul>
<p>The argument is always the resource name without the file extension. For textures and shaders, the name is just the name of the file without the extension. For models and skyboxes, it's the name of the directory, because they have multiple files associated with them.</p>
<p>The pointer to the <code>resource</code> that the <code>ResourcesController</code> returns is a <em>non-owning pointer</em>, meaning you should <b>Never call delete on it.</b> All the memory is managed by the <code>ResourcesController.</code></p>
<h3><a class="anchor" id="autotoc_md11"></a>
How do you set up a basic app?</h3>
<p>For a basic app setup, you need to:</p>
<ol type="1">
<li>Create a class for your App, let's call it <code>MyApp</code>, in the src/.</li>
<li>Inherit from the <code><a class="el" href="d0/d12/classengine_1_1core_1_1App.html" title="Defines the base App class that serves as the application core structure and the entry point.">engine::core::App</a></code> and implement <code>app_setup()</code>.</li>
<li>Instantiate <code>MyApp</code> object in the <code>main</code> function and call <code>run</code> on it.</li>
<li>Compile and run the program.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;engine/Engne.hpp&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyApp : <span class="keyword">public</span> <a class="code" href="d0/d12/classengine_1_1core_1_1App.html">engine::core::App</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::user_setup() {</div>
<div class="line">    spdlog::info(<span class="stringliteral">&quot;Hello, setup!&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="db/dd3/TestApp_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;MyApp&gt;()-&gt;run(argc, argv);</div>
<div class="line">}</div>
<div class="ttc" id="aTestApp_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="db/dd3/TestApp_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> TestApp.cpp:14</div></div>
<div class="ttc" id="aclassengine_1_1core_1_1App_html"><div class="ttname"><a href="d0/d12/classengine_1_1core_1_1App.html">engine::core::App</a></div><div class="ttdoc">Defines the base App class that serves as the application core structure and the entry point.</div><div class="ttdef"><b>Definition:</b> App.hpp:45</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
How are &lt;tt&gt;resources&lt;/tt&gt; managed?</h3>
<p>Resources currently include: <code>textures</code>, <code>shaders</code>, <code>models</code>, <code>skyboxes</code>. The <code>ResourcesController</code> manages the loading, storing, and accessing the resource objects. During the <code>App::initialize</code>, the <code>ResourcesController</code> will load all the resources in the <code>resources</code> directory.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
How to add a model?</h3>
<p>The <code>resources/models/</code> directory stores all the models. Let's add a backpack model from the course.</p>
<ol type="1">
<li>Create a directory, <code>resources/models/backpack.</code></li>
<li>Copy the <code>backpack</code> model files into the <code>resources/models/backpack</code>.</li>
<li>Add a configuration for your model in the config.json</li>
</ol>
<div class="fragment"><div class="line">&quot;resources&quot;: {</div>
<div class="line">   &quot;models&quot;: {</div>
<div class="line">     &quot;backpack&quot;: { # &lt;--- This will be the name of the model you use in the app</div>
<div class="line">       &quot;path&quot;: &quot;backpack/backpack.obj&quot;, # &lt;---- Relative path to the .obj file</div>
<div class="line">       &quot;flip_uvs&quot;: false # &lt;---- whether the loader should flip the texture coordinates</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> }</div>
</div><!-- fragment --><ol type="1">
<li>The <code>ResourcesController</code> will automatically load this model during <code>ResourcesController::initialize()</code>; you should see a log:</li>
</ol>
<div class="fragment"><div class="line">...</div>
<div class="line">[2024-12-08 11:19:12.347] [info] load_model(backpack, resources/models/backpack/backpack.obj)</div>
<div class="line">[2024-12-08 11:19:13.272] [info] Loading texture: resources/models/backpack/diffuse.jpg</div>
<div class="line">[2024-12-08 11:19:14.114] [info] Loading texture: resources/models/backpack/specular.jpg</div>
<div class="line">[2024-12-08 11:19:14.479] [info] Loading texture: resources/models/backpack/normal.png</div>
<div class="line">...</div>
</div><!-- fragment --><ol type="1">
<li>Use the model in your App:</li>
</ol>
<div class="fragment"><div class="line">Model* backpack = engine::core::Controller::get&lt;engine::resources::ResourcesController&gt;()-&gt;model(<span class="stringliteral">&quot;backpack&quot;</span>);</div>
<div class="line">Shader* shader   = ... </div>
<div class="line">backpack-&gt;draw(shader);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
How to add a texture?</h3>
<ol type="1">
<li>Add a texture file <code>awesomeface.png</code> to the <code>resources/textures</code> directory</li>
<li>Use it in the App (<code>ResourcesController</code> will automatically load it)</li>
</ol>
<div class="fragment"><div class="line">Texture* texture = engine::core::Controller::get&lt;ResourcesController&gt;()-&gt;texture(<span class="stringliteral">&quot;awesomeface&quot;</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
How to add a shader?</h3>
<ol type="1">
<li>Create a <code>your_shader.glsl</code> in the <code>resources/shaders/your_shader.glsl</code>.</li>
<li>Implement <code>vertex</code>, <code>fragment</code>, and <code>geometry</code> (optional), shaders in the same file.</li>
<li>Use it in the App:</li>
</ol>
<div class="fragment"><div class="line">Shader* shader = engine::core::Controller::get&lt;ResourcesController&gt;()-&gt;shader(<span class="stringliteral">&quot;your_shader&quot;</span>);</div>
<div class="line">Model* backpack = ...;</div>
<div class="line">backpack-&gt;draw(shader);</div>
</div><!-- fragment --><p>Vertex, fragment, and geometry shaders are written in the same file. Use the <code>// #shader vertex|fragment|geometry</code> to declare the start of the shader. Here is an example:</p>
<div class="fragment"><div class="line">//#shader vertex</div>
<div class="line">#version 330 core</div>
<div class="line">layout (location = 0) in vec3 aPos;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    gl_Position = vec4(aPos, 1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//#shader fragment</div>
<div class="line">#version 330 core</div>
<div class="line"> </div>
<div class="line">out vec4 FragColor;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    FragColor = vec4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>ResourcesController</code> will load and compile all the shaders in the <code>resources/shaders</code> directory.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
How to draw a GUI?</h3>
<p><code>Engine</code> uses the <a href="https://github.com/ocornut/imgui">imgui</a> library to draw a GUI. See the library page for more examples. For GUI to be visible it should be drawn last, after all the world objects. Here is an example of displaying camera info in a GUI.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> graphics = engine::core::Controller::get&lt;engine::graphics::GraphicsController&gt;();</div>
<div class="line">graphics-&gt;begin_gui();</div>
<div class="line"><span class="comment">// Draw Camera Info window</span></div>
<div class="line">{</div>
<div class="line">    ImGui::Begin(<span class="stringliteral">&quot;Camera info&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;c = *camera;</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;Camera position: (%f, %f, %f)&quot;</span>, c.Position.x, c.Position.y, c.Position.z);</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;(Yaw, Pitch): (%f, %f)&quot;</span>, c.Yaw, c.Pitch);</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;Camera front: (%f, %f, %f)&quot;</span>, c.Front.x, c.Front.y, c.Front.z);</div>
<div class="line">    ImGui::End();</div>
<div class="line">}</div>
<div class="line">graphics-&gt;end_gui();</div>
</div><!-- fragment --><p><img src="../extra/img.png" alt="img.png" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md17"></a>
How do you throw and handle errors?</h3>
<p>The <code>Engine</code> defines a base <code>Error</code> type with two subclasses, <code>EngineError</code> and <code>UserError</code>. They serve as a <em>graceful</em> way to terminate the application and provide the user with some helpful information on how to <b>fix</b> the error.</p>
<p>For example, the <code>ResourcesController</code> will throw <code>AssetLoadingError</code> if it can't read the model file.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) {</div>
<div class="line">    <span class="keywordflow">throw</span> util::EngineError(util::EngineError::Type::AssetLoadingError,</div>
<div class="line">                            std::format(<span class="stringliteral">&quot;Assimp error while reading model: {} from path {}.&quot;</span>,</div>
<div class="line">                                        model_path.string(), name));</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>Exceptions</code> shouldn't be used as a control-flow mechanism but only to inform the user of an <code>exceptional</code> event that the program can't do anything about, like the missing asset file.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
How to get the key/mouse press event?</h3>
<p>The <code>PlatformController</code> differentiates between four types of button/key states:</p>
<ol type="1">
<li><code><a class="el" href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8ac2e67bf45734245fb60def6a8059c06c" title="The key has just been pressed in the current frame. This state only lasts for the frame in which the ...">engine::platform::Key::State::JustPressed</a></code> -&gt; Only in the first frame when the button was registered as pressed</li>
<li><code><a class="el" href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8ad78a68f6a85421ae121c2cb5b73a1040" title="The key is being held down. If the key was JustPressed in the previous frame, and it is still down in...">engine::platform::Key::State::Pressed</a></code> -&gt; Every subsequent frame if the button is still held</li>
<li><code><a class="el" href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8a3621e68a905d433b120899458aeda38d" title="Lasts only for the frame in which the key was released. In the next frame, if the key is not pressed ...">engine::platform::Key::State::JustReleased</a></code> -&gt; Just the first frame in which the button was registered as released</li>
<li><code><a class="el" href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8aea1e34304a5d8ffa7c9b0ed8ede4ef1a" title="The key is up.">engine::platform::Key::State::Released</a></code> -&gt; Button is not pressed</li>
</ol>
<p>Use the <code>PlatformController::key</code> method to get the state of the key in a given frame:</p>
<p>Here is an example of turning GUI on/off drawing using the <code>F2</code> key:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> poll_events()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> platform = engine::core::Controller::get&lt;engine::platform::PlatformController&gt;();</div>
<div class="line">    <span class="keywordflow">if</span> (platform-&gt;key(<a class="code" href="df/dc9/namespaceengine_1_1platform.html#a4df2e829d2604f662af9656d1aec5ca4a3555aeceba7eec0293dd35c052526d4b">engine::platform::KeyId::KEY_F2</a>).state() == <a class="code" href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8ac2e67bf45734245fb60def6a8059c06c">engine::platform::Key::State::JustPressed</a>) {</div>
<div class="line">        m_draw_gui = !m_draw_gui;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassengine_1_1platform_1_1Key_html_ab99e725fa6c12a927b3ced069261ebf8ac2e67bf45734245fb60def6a8059c06c"><div class="ttname"><a href="d4/d4a/classengine_1_1platform_1_1Key.html#ab99e725fa6c12a927b3ced069261ebf8ac2e67bf45734245fb60def6a8059c06c">engine::platform::Key::State::JustPressed</a></div><div class="ttdeci">@ JustPressed</div><div class="ttdoc">The key has just been pressed in the current frame. This state only lasts for the frame in which the ...</div></div>
<div class="ttc" id="anamespaceengine_1_1platform_html_a4df2e829d2604f662af9656d1aec5ca4a3555aeceba7eec0293dd35c052526d4b"><div class="ttname"><a href="df/dc9/namespaceengine_1_1platform.html#a4df2e829d2604f662af9656d1aec5ca4a3555aeceba7eec0293dd35c052526d4b">engine::platform::KEY_F2</a></div><div class="ttdeci">@ KEY_F2</div><div class="ttdef"><b>Definition:</b> Input.hpp:97</div></div>
</div><!-- fragment --><p>Keys have a unique identifier: via <code><a class="el" href="df/dc9/namespaceengine_1_1platform.html#a4df2e829d2604f662af9656d1aec5ca4" title="All the Keys that the engine can register.">engine::platform::KeyId</a></code>.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
How to register a callback for platform events?</h3>
<p>Registering callbacks for platform events via: <code>PlatformEventObserver</code> is also available.</p>
<ol type="1">
<li>Implement the event observer by extending the class <code><a class="el" href="dc/d04/classengine_1_1platform_1_1PlatformEventObserver.html" title="Platform events callback object. Extend this class and override the methods you want to be called by ...">engine::platform::PlatformEventObserver</a></code>, and override methods you'd like to have a custom operation executed once the event happens</li>
<li>Register the <code>observer</code> instance in the <code>PlatformController</code>.</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">class </span>MainPlatformEventObserver final : <span class="keyword">public</span> <a class="code" href="dc/d04/classengine_1_1platform_1_1PlatformEventObserver.html">engine::platform::PlatformEventObserver</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> on_keyboard(<a class="code" href="d4/d4a/classengine_1_1platform_1_1Key.html">engine::platform::Key</a> key)<span class="keyword"> override </span>{</div>
<div class="line">        spdlog::info(<span class="stringliteral">&quot;Keyboard event: key={}, state={}&quot;</span>, key.<a class="code" href="d4/d4a/classengine_1_1platform_1_1Key.html#aa58158c068d08a7bc5ac0ca2b6afdad8">name</a>(), key.<a class="code" href="d4/d4a/classengine_1_1platform_1_1Key.html#ac644da48edda5fa24979b5dbd0e5db97">state_str</a>());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>MainController : <span class="keyword">public</span> <a class="code" href="d1/d39/classengine_1_1core_1_1Controller.html">engine::core::Controller</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="d1/d39/classengine_1_1core_1_1Controller.html#a0e6251130770075738a5b1fa9997145f">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// ... </span></div>
<div class="line">        <span class="keyword">auto</span> observer = std::make_unique&lt;MainPlatformEventObserver&gt;();</div>
<div class="line">        engine::core::Controller::get&lt;engine::platform::PlatformController&gt;()-&gt;register_platform_event_observer(std::move(observer));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassengine_1_1core_1_1Controller_html"><div class="ttname"><a href="d1/d39/classengine_1_1core_1_1Controller.html">engine::core::Controller</a></div><div class="ttdoc">Controllers are a hook into the App main loop execution. By overriding virtual functions of this clas...</div><div class="ttdef"><b>Definition:</b> Controller.hpp:42</div></div>
<div class="ttc" id="aclassengine_1_1core_1_1Controller_html_a0e6251130770075738a5b1fa9997145f"><div class="ttname"><a href="d1/d39/classengine_1_1core_1_1Controller.html#a0e6251130770075738a5b1fa9997145f">engine::core::Controller::initialize</a></div><div class="ttdeci">virtual void initialize()</div><div class="ttdoc">Initializes the controller. Executes in the core::App::initialize.</div><div class="ttdef"><b>Definition:</b> Controller.hpp:129</div></div>
<div class="ttc" id="aclassengine_1_1platform_1_1Key_html"><div class="ttname"><a href="d4/d4a/classengine_1_1platform_1_1Key.html">engine::platform::Key</a></div><div class="ttdoc">Represents the state of the key in a given frame.</div><div class="ttdef"><b>Definition:</b> Input.hpp:154</div></div>
<div class="ttc" id="aclassengine_1_1platform_1_1Key_html_aa58158c068d08a7bc5ac0ca2b6afdad8"><div class="ttname"><a href="d4/d4a/classengine_1_1platform_1_1Key.html#aa58158c068d08a7bc5ac0ca2b6afdad8">engine::platform::Key::name</a></div><div class="ttdeci">std::string_view name()</div><div class="ttdef"><b>Definition:</b> PlatformController.cpp:159</div></div>
<div class="ttc" id="aclassengine_1_1platform_1_1Key_html_ac644da48edda5fa24979b5dbd0e5db97"><div class="ttname"><a href="d4/d4a/classengine_1_1platform_1_1Key.html#ac644da48edda5fa24979b5dbd0e5db97">engine::platform::Key::state_str</a></div><div class="ttdeci">std::string_view state_str() const</div><div class="ttdef"><b>Definition:</b> PlatformController.cpp:163</div></div>
<div class="ttc" id="aclassengine_1_1platform_1_1PlatformEventObserver_html"><div class="ttname"><a href="dc/d04/classengine_1_1platform_1_1PlatformEventObserver.html">engine::platform::PlatformEventObserver</a></div><div class="ttdoc">Platform events callback object. Extend this class and override the methods you want to be called by ...</div><div class="ttdef"><b>Definition:</b> PlatformEventObserver.hpp:17</div></div>
</div><!-- fragment --><p>Now, for every keyboard event, the <code>PlatformController</code> will call <code>MainPlatformEventObserver::on_keyboard</code> and pass the <code>key</code> on which the event occurred as an argument.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
How do you get Window properties?</h3>
<p><code>PlatformController</code> initializes and stores the <code>Window</code> handle, which you can access via:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> platform = engine::core::Controller::get&lt;engine::platform::PlatformController&gt;();</div>
<div class="line">platform-&gt;window()-&gt;height()</div>
<div class="line">platform-&gt;window()-&gt;width()</div>
<div class="line">platform-&gt;window()-&gt;title()</div>
</div><!-- fragment --><p>Also, the <code>PlatformController</code> will update the window properties if the size of the window changes.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
How to add new OpenGL calls?</h3>
<p>Rendering actions that require more than one OpenGL call should be abstracted in the <code><a class="el" href="df/d0b/classengine_1_1graphics_1_1OpenGL.html" title="This class serves as the OpenGL interface for your app, since the engine doesn&#39;t directly link OpenGL...">engine::graphics::OpenGL</a></code> class. For example, <code>OpenGL::compile_shaer</code> compiles a GLSL shader and returns the shader_id.</p>
<div class="fragment"><div class="line">uint32_t OpenGL::compile_shader(<span class="keyword">const</span> std::string &amp;shader_source,</div>
<div class="line">                                <a class="code" href="d6/dc3/namespaceengine_1_1resources.html#a6154ce2c554f664f76ac159b9c6cf553">resources::ShaderType</a> shader_type) {</div>
<div class="line">    uint32_t shader_id             = <a class="code" href="d7/db9/OpenGL_8hpp.html#a6605a80a0c40878b90d101747bbd7702">CHECKED_GL_CALL</a>(glCreateShader, shader_type_to_opengl_type(shader_type));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *shader_source_cstr = shader_source.c_str();</div>
<div class="line">    <a class="code" href="d7/db9/OpenGL_8hpp.html#a6605a80a0c40878b90d101747bbd7702">CHECKED_GL_CALL</a>(glShaderSource, shader_id, 1, &amp;shader_source_cstr, <span class="keyword">nullptr</span>);</div>
<div class="line">    <a class="code" href="d7/db9/OpenGL_8hpp.html#a6605a80a0c40878b90d101747bbd7702">CHECKED_GL_CALL</a>(glCompileShader, shader_id);</div>
<div class="line">    <span class="keywordflow">return</span> shader_id;</div>
<div class="line">}</div>
<div class="ttc" id="aOpenGL_8hpp_html_a6605a80a0c40878b90d101747bbd7702"><div class="ttname"><a href="d7/db9/OpenGL_8hpp.html#a6605a80a0c40878b90d101747bbd7702">CHECKED_GL_CALL</a></div><div class="ttdeci">#define CHECKED_GL_CALL(func,...)</div><div class="ttdoc">Do an error-checked OpenGL call. Throws an OpenGL error if the call fails.</div><div class="ttdef"><b>Definition:</b> OpenGL.hpp:27</div></div>
<div class="ttc" id="anamespaceengine_1_1resources_html_a6154ce2c554f664f76ac159b9c6cf553"><div class="ttname"><a href="d6/dc3/namespaceengine_1_1resources.html#a6154ce2c554f664f76ac159b9c6cf553">engine::resources::ShaderType</a></div><div class="ttdeci">ShaderType</div><div class="ttdoc">The type of the shader.</div><div class="ttdef"><b>Definition:</b> Shader.hpp:19</div></div>
</div><!-- fragment --><p>If the OpenGL call fails, the <code>CHECK_GL_CALL</code> macro throws an <code>OpenGLError</code> in DEBUG mode. The engine will print the error description of and the source location in which it occurred.</p>
<p>Why this way? It's less error-prone and more straightforward to add debugging assertions and error checks if needed.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
How do you add a custom controller?</h3>
<p><code>Controllers</code> are a way to hook into the engine execution. To create a custom controller:</p>
<ol type="1">
<li>Create a custom controller class that extends the <code><a class="el" href="d1/d39/classengine_1_1core_1_1Controller.html" title="Controllers are a hook into the App main loop execution. By overriding virtual functions of this clas...">engine::core::Controller</a></code></li>
<li>Implement for the phase (<code>initialize</code>, <code>loop</code>, <code>poll_events</code>, <code>update</code>, <code>begin_draw</code>, <code>draw</code>, <code>end_draw</code>, <code>terminate</code>) for which you want to execute custom code.</li>
<li>Register the controller in the <code>MainApp::user_setup</code>.</li>
</ol>
<p>Here is the example of creating the <code>MainController</code> that enables <code>depth testing</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MainController : <span class="keyword">public</span> <a class="code" href="d1/d39/classengine_1_1core_1_1Controller.html">engine::core::Controller</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="d1/d39/classengine_1_1core_1_1Controller.html#a0e6251130770075738a5b1fa9997145f">initialize</a>()<span class="keyword"> override </span>{</div>
<div class="line">        <a class="code" href="df/d0b/classengine_1_1graphics_1_1OpenGL.html#a217e05a1572138e9c378308a1a4c272d">engine::graphics::OpenGL::enable_depth_testing</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>MainApp final : <span class="keyword">public</span> <a class="code" href="d0/d12/classengine_1_1core_1_1App.html">engine::core::App</a> {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> main_controller = engine::controller::register_controller&lt;MainController&gt;();</div>
<div class="line">        <span class="comment">/* Make sure that the main_controller executes after all the engine controllers. */</span></div>
<div class="line">        main_controller-&gt;after(engine::core::Controller::get&lt;engine::controller::EngineSentinelController&gt;());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassengine_1_1graphics_1_1OpenGL_html_a217e05a1572138e9c378308a1a4c272d"><div class="ttname"><a href="df/d0b/classengine_1_1graphics_1_1OpenGL.html#a217e05a1572138e9c378308a1a4c272d">engine::graphics::OpenGL::enable_depth_testing</a></div><div class="ttdeci">static void enable_depth_testing()</div><div class="ttdoc">Enables depth testing.</div><div class="ttdef"><b>Definition:</b> OpenGL.cpp:165</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
How do you add a configuration option?</h3>
<p>You can configure some parts of the <code>engine</code> in the <code>config.json</code>. For example, we can configure the size and the title of the window when the application starts.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;window&quot;: {</div>
<div class="line">    &quot;height&quot;: 600,</div>
<div class="line">    &quot;title&quot;: &quot;Hello, window!&quot;,</div>
<div class="line">    &quot;width&quot;: 800</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can also add your custom configuration options:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;exposure&quot;: 2.45,</div>
<div class="line">  &quot;on_exit_message&quot;: &quot;Bye...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and use them:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> &amp;config = util::Configuration::config();</div>
<div class="line"><span class="keywordtype">float</span> exposure = config[<span class="stringliteral">&quot;exposure&quot;</span>].get&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">std::string gamma = config[<span class="stringliteral">&quot;on_exit_message&quot;</span>].get&lt;std::string&gt;();</div>
</div><!-- fragment --><p>The <code>Configuration</code> class uses <a href="https://github.com/nlohmann/json">nlohmann/json</a> library to load and store <code>json</code> files, see the library page for documentation.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
How to pass a command line argument?</h3>
<p>You use the <code>ArgParser</code> to parse the command line arguments anywhere from the program. For example, for the invocation command: <code>./matf-rg-engine ... --fps 120</code>, the <code>parser-&gt;arg("--fps")</code> will return the value 60. If the argument is not present, it will return the default value passed as the second argument to the <code>arg</code> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keyword">auto</span> parser = <a class="code" href="d4/dd0/classengine_1_1util_1_1ArgParser.html">engine::util::ArgParser</a>()-&gt;<a class="code" href="d4/dd0/classengine_1_1util_1_1ArgParser.html#a23de3dfbfaf53b3ace40c85dfa996121">instance</a>();</div>
<div class="line">    <span class="keyword">auto</span> fps = parser-&gt;<a class="code" href="d4/dd0/classengine_1_1util_1_1ArgParser.html#a14dc9469a7b5e96cb741d2b4a2804bfd">arg</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;--fps&quot;</span>, 60);</div>
<div class="line">}</div>
<div class="ttc" id="aclassengine_1_1util_1_1ArgParser_html"><div class="ttname"><a href="d4/dd0/classengine_1_1util_1_1ArgParser.html">engine::util::ArgParser</a></div><div class="ttdoc">Parses command line arguments.</div><div class="ttdef"><b>Definition:</b> ArgParser.hpp:17</div></div>
<div class="ttc" id="aclassengine_1_1util_1_1ArgParser_html_a14dc9469a7b5e96cb741d2b4a2804bfd"><div class="ttname"><a href="d4/dd0/classengine_1_1util_1_1ArgParser.html#a14dc9469a7b5e96cb741d2b4a2804bfd">engine::util::ArgParser::arg</a></div><div class="ttdeci">std::optional&lt; T &gt; arg(std::string_view name, std::optional&lt; T &gt; default_value={})</div><div class="ttdoc">Get the value of an argument. Supported types: bool, int, long long, float, double,...</div><div class="ttdef"><b>Definition:</b> ArgParser.hpp:32</div></div>
<div class="ttc" id="aclassengine_1_1util_1_1ArgParser_html_a23de3dfbfaf53b3ace40c85dfa996121"><div class="ttname"><a href="d4/dd0/classengine_1_1util_1_1ArgParser.html#a23de3dfbfaf53b3ace40c85dfa996121">engine::util::ArgParser::instance</a></div><div class="ttdeci">static ArgParser * instance()</div><div class="ttdef"><b>Definition:</b> Utils.cpp:78</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25"></a>
Tutorials</h1>
<h2><a class="anchor" id="autotoc_md26"></a>
App test tutorial</h2>
<p>Here you can find a walkthrough <a class="el" href="de/dce/md_engine_test_app_TUTORIAL.html">tutorial</a> for recreating the <code>engine/test/app</code> that demonstrates how to use different engine systems. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
